#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Jan 25 13:17:29 2011 by generateDS.py version 2.3b.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_str_lower(self, instring):
            return instring.lower()
                    
                    

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class node(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hardware=None, software=None, cloud=None):
        self.hardware = hardware
        self.software = software
        self.cloud = cloud
    def factory(*args_, **kwargs_):
        if node.subclass:
            return node.subclass(*args_, **kwargs_)
        else:
            return node(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hardware(self): return self.hardware
    def set_hardware(self, hardware): self.hardware = hardware
    def get_software(self): return self.software
    def set_software(self, software): self.software = software
    def get_cloud(self): return self.cloud
    def set_cloud(self, cloud): self.cloud = cloud
    def export(self, outfile, level, namespace_='', name_='node', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='node')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='node'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='node'):
        if self.hardware:
            self.hardware.export(outfile, level, namespace_, name_='hardware', )
        if self.software:
            self.software.export(outfile, level, namespace_, name_='software', )
        if self.cloud:
            self.cloud.export(outfile, level, namespace_, name_='cloud', )
    def hasContent_(self):
        if (
            self.hardware is not None or
            self.software is not None or
            self.cloud is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='node'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.hardware is not None:
            showIndent(outfile, level)
            outfile.write('hardware=model_.hardware(\n')
            self.hardware.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.software is not None:
            showIndent(outfile, level)
            outfile.write('software=model_.software(\n')
            self.software.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cloud is not None:
            showIndent(outfile, level)
            outfile.write('cloud=model_.cloud(\n')
            self.cloud.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'hardware': 
            obj_ = hardware.factory()
            obj_.build(child_)
            self.set_hardware(obj_)
        elif nodeName_ == 'software': 
            obj_ = software.factory()
            obj_.build(child_)
            self.set_software(obj_)
        elif nodeName_ == 'cloud': 
            obj_ = cloud.factory()
            obj_.build(child_)
            self.set_cloud(obj_)
# end class node


class hardware(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cpus=None, virtualization=None, memory=None, nics=None, partitions=None):
        self.cpus = cpus
        self.virtualization = virtualization
        self.memory = memory
        self.nics = nics
        self.partitions = partitions
    def factory(*args_, **kwargs_):
        if hardware.subclass:
            return hardware.subclass(*args_, **kwargs_)
        else:
            return hardware(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpus(self): return self.cpus
    def set_cpus(self, cpus): self.cpus = cpus
    def get_virtualization(self): return self.virtualization
    def set_virtualization(self, virtualization): self.virtualization = virtualization
    def get_memory(self): return self.memory
    def set_memory(self, memory): self.memory = memory
    def get_nics(self): return self.nics
    def set_nics(self, nics): self.nics = nics
    def get_partitions(self): return self.partitions
    def set_partitions(self, partitions): self.partitions = partitions
    def export(self, outfile, level, namespace_='', name_='hardware', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='hardware')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='hardware'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='hardware'):
        if self.cpus:
            self.cpus.export(outfile, level, namespace_, name_='cpus', )
        if self.virtualization is not None:
            showIndent(outfile, level)
            outfile.write('<%svirtualization>%s</%svirtualization>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.virtualization)), input_name='virtualization'), namespace_))
        if self.memory is not None:
            showIndent(outfile, level)
            outfile.write('<%smemory>%s</%smemory>\n' % (namespace_, self.gds_format_integer(self.memory, input_name='memory'), namespace_))
        if self.nics:
            self.nics.export(outfile, level, namespace_, name_='nics', )
        if self.partitions:
            self.partitions.export(outfile, level, namespace_, name_='partitions', )
    def hasContent_(self):
        if (
            self.cpus is not None or
            self.virtualization is not None or
            self.memory is not None or
            self.nics is not None or
            self.partitions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='hardware'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cpus is not None:
            showIndent(outfile, level)
            outfile.write('cpus=model_.cpus(\n')
            self.cpus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.virtualization is not None:
            showIndent(outfile, level)
            outfile.write('virtualization=%s,\n' % self.virtualization)
        if self.memory is not None:
            showIndent(outfile, level)
            outfile.write('memory=%d,\n' % self.memory)
        if self.nics is not None:
            showIndent(outfile, level)
            outfile.write('nics=model_.nics(\n')
            self.nics.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.partitions is not None:
            showIndent(outfile, level)
            outfile.write('partitions=model_.partitions(\n')
            self.partitions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'cpus': 
            obj_ = cpus.factory()
            obj_.build(child_)
            self.set_cpus(obj_)
        elif nodeName_ == 'virtualization':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            self.virtualization = ival_
        elif nodeName_ == 'memory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.memory = ival_
        elif nodeName_ == 'nics': 
            obj_ = nics.factory()
            obj_.build(child_)
            self.set_nics(obj_)
        elif nodeName_ == 'partitions': 
            obj_ = partitions.factory()
            obj_.build(child_)
            self.set_partitions(obj_)
# end class hardware


class cpus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cpu=None):
        if cpu is None:
            self.cpu = []
        else:
            self.cpu = cpu
    def factory(*args_, **kwargs_):
        if cpus.subclass:
            return cpus.subclass(*args_, **kwargs_)
        else:
            return cpus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpu(self): return self.cpu
    def set_cpu(self, cpu): self.cpu = cpu
    def add_cpu(self, value): self.cpu.append(value)
    def insert_cpu(self, index, value): self.cpu[index] = value
    def export(self, outfile, level, namespace_='', name_='cpus', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='cpus')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cpus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cpus'):
        for cpu_ in self.cpu:
            cpu_.export(outfile, level, namespace_, name_='cpu')
    def hasContent_(self):
        if (
            self.cpu
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cpus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cpu=[\n')
        level += 1
        for cpu_ in self.cpu:
            showIndent(outfile, level)
            outfile.write('model_.cpu(\n')
            cpu_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'cpu': 
            obj_ = cpu.factory()
            obj_.build(child_)
            self.cpu.append(obj_)
# end class cpus


class cpu(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cores=None, speed=None, name=None, valueOf_=None):
        self.cores = _cast(int, cores)
        self.speed = _cast(int, speed)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cpu.subclass:
            return cpu.subclass(*args_, **kwargs_)
        else:
            return cpu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cores(self): return self.cores
    def set_cores(self, cores): self.cores = cores
    def get_speed(self): return self.speed
    def set_speed(self, speed): self.speed = speed
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='cpu', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='cpu')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cpu'):
        outfile.write(' cores="%s"' % self.gds_format_integer(self.cores, input_name='cores'))
        outfile.write(' speed="%s"' % self.gds_format_integer(self.speed, input_name='speed'))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cpu'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cpu'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cores is not None and 'cores' not in already_processed:
            already_processed.append('cores')
            showIndent(outfile, level)
            outfile.write('cores = %d,\n' % (self.cores,))
        if self.speed is not None and 'speed' not in already_processed:
            already_processed.append('speed')
            showIndent(outfile, level)
            outfile.write('speed = %d,\n' % (self.speed,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('cores')
        if value is not None and 'cores' not in already_processed:
            already_processed.append('cores')
            try:
                self.cores = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('speed')
        if value is not None and 'speed' not in already_processed:
            already_processed.append('speed')
            try:
                self.speed = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class cpu


class nics(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nic=None):
        if nic is None:
            self.nic = []
        else:
            self.nic = nic
    def factory(*args_, **kwargs_):
        if nics.subclass:
            return nics.subclass(*args_, **kwargs_)
        else:
            return nics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nic(self): return self.nic
    def set_nic(self, nic): self.nic = nic
    def add_nic(self, value): self.nic.append(value)
    def insert_nic(self, index, value): self.nic[index] = value
    def export(self, outfile, level, namespace_='', name_='nics', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='nics')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nics'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nics'):
        for nic_ in self.nic:
            nic_.export(outfile, level, namespace_, name_='nic')
    def hasContent_(self):
        if (
            self.nic
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nics'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('nic=[\n')
        level += 1
        for nic_ in self.nic:
            showIndent(outfile, level)
            outfile.write('model_.nic(\n')
            nic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'nic': 
            obj_ = nic.factory()
            obj_.build(child_)
            self.nic.append(obj_)
# end class nics


class nic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, interface=None, type_=None, name=None, valueOf_=None):
        self.interface = _cast(None, interface)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nic.subclass:
            return nic.subclass(*args_, **kwargs_)
        else:
            return nic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interface(self): return self.interface
    def set_interface(self, interface): self.interface = interface
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='nic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='nic')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nic'):
        outfile.write(' interface=%s' % (self.gds_format_string(quote_attrib(self.interface).encode(ExternalEncoding), input_name='interface'), ))
        outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='nic'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interface is not None and 'interface' not in already_processed:
            already_processed.append('interface')
            showIndent(outfile, level)
            outfile.write('interface = "%s",\n' % (self.interface,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('interface')
        if value is not None and 'interface' not in already_processed:
            already_processed.append('interface')
            self.interface = value
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class nic


class partitions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, partition=None):
        if partition is None:
            self.partition = []
        else:
            self.partition = partition
    def factory(*args_, **kwargs_):
        if partitions.subclass:
            return partitions.subclass(*args_, **kwargs_)
        else:
            return partitions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partition(self): return self.partition
    def set_partition(self, partition): self.partition = partition
    def add_partition(self, value): self.partition.append(value)
    def insert_partition(self, index, value): self.partition[index] = value
    def export(self, outfile, level, namespace_='', name_='partitions', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='partitions')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='partitions'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='partitions'):
        for partition_ in self.partition:
            partition_.export(outfile, level, namespace_, name_='partition')
    def hasContent_(self):
        if (
            self.partition
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='partitions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('partition=[\n')
        level += 1
        for partition_ in self.partition:
            showIndent(outfile, level)
            outfile.write('model_.partition(\n')
            partition_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'partition': 
            obj_ = partition.factory()
            obj_.build(child_)
            self.partition.append(obj_)
# end class partitions


class partition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, device=None, mountpoint=None, used=None, size=None, valueOf_=None):
        self.device = _cast(None, device)
        self.mountpoint = _cast(None, mountpoint)
        self.used = _cast(int, used)
        self.size = _cast(int, size)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if partition.subclass:
            return partition.subclass(*args_, **kwargs_)
        else:
            return partition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_mountpoint(self): return self.mountpoint
    def set_mountpoint(self, mountpoint): self.mountpoint = mountpoint
    def get_used(self): return self.used
    def set_used(self, used): self.used = used
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='partition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='partition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='partition'):
        outfile.write(' device=%s' % (self.gds_format_string(quote_attrib(self.device).encode(ExternalEncoding), input_name='device'), ))
        outfile.write(' mountpoint=%s' % (self.gds_format_string(quote_attrib(self.mountpoint).encode(ExternalEncoding), input_name='mountpoint'), ))
        outfile.write(' used="%s"' % self.gds_format_integer(self.used, input_name='used'))
        outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='partition'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='partition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.device is not None and 'device' not in already_processed:
            already_processed.append('device')
            showIndent(outfile, level)
            outfile.write('device = "%s",\n' % (self.device,))
        if self.mountpoint is not None and 'mountpoint' not in already_processed:
            already_processed.append('mountpoint')
            showIndent(outfile, level)
            outfile.write('mountpoint = "%s",\n' % (self.mountpoint,))
        if self.used is not None and 'used' not in already_processed:
            already_processed.append('used')
            showIndent(outfile, level)
            outfile.write('used = %d,\n' % (self.used,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = %d,\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('device')
        if value is not None and 'device' not in already_processed:
            already_processed.append('device')
            self.device = value
        value = attrs.get('mountpoint')
        if value is not None and 'mountpoint' not in already_processed:
            already_processed.append('mountpoint')
            self.mountpoint = value
        value = attrs.get('used')
        if value is not None and 'used' not in already_processed:
            already_processed.append('used')
            try:
                self.used = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('size')
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            try:
                self.size = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class partition


class software(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, os=None):
        self.os = os
    def factory(*args_, **kwargs_):
        if software.subclass:
            return software.subclass(*args_, **kwargs_)
        else:
            return software(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_os(self): return self.os
    def set_os(self, os): self.os = os
    def export(self, outfile, level, namespace_='', name_='software', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='software')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='software'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='software'):
        if self.os:
            self.os.export(outfile, level, namespace_, name_='os', )
    def hasContent_(self):
        if (
            self.os is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='software'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.os is not None:
            showIndent(outfile, level)
            outfile.write('os=model_.os(\n')
            self.os.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'os': 
            obj_ = os.factory()
            obj_.build(child_)
            self.set_os(obj_)
# end class software


class os(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uname=None, network=None):
        self.uname = _cast(None, uname)
        self.network = network
    def factory(*args_, **kwargs_):
        if os.subclass:
            return os.subclass(*args_, **kwargs_)
        else:
            return os(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def get_uname(self): return self.uname
    def set_uname(self, uname): self.uname = uname
    def export(self, outfile, level, namespace_='', name_='os', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='os')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='os'):
        outfile.write(' uname=%s' % (self.gds_format_string(quote_attrib(self.uname).encode(ExternalEncoding), input_name='uname'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='os'):
        if self.network:
            self.network.export(outfile, level, namespace_, name_='network', )
    def hasContent_(self):
        if (
            self.network is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='os'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uname is not None and 'uname' not in already_processed:
            already_processed.append('uname')
            showIndent(outfile, level)
            outfile.write('uname = "%s",\n' % (self.uname,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.network is not None:
            showIndent(outfile, level)
            outfile.write('network=model_.network(\n')
            self.network.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('uname')
        if value is not None and 'uname' not in already_processed:
            already_processed.append('uname')
            self.uname = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'network': 
            obj_ = network.factory()
            obj_.build(child_)
            self.set_network(obj_)
# end class os


class network(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hostname=None, nameserver=None, iface=None):
        self.hostname = _cast(None, hostname)
        if nameserver is None:
            self.nameserver = []
        else:
            self.nameserver = nameserver
        if iface is None:
            self.iface = []
        else:
            self.iface = iface
    def factory(*args_, **kwargs_):
        if network.subclass:
            return network.subclass(*args_, **kwargs_)
        else:
            return network(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nameserver(self): return self.nameserver
    def set_nameserver(self, nameserver): self.nameserver = nameserver
    def add_nameserver(self, value): self.nameserver.append(value)
    def insert_nameserver(self, index, value): self.nameserver[index] = value
    def get_iface(self): return self.iface
    def set_iface(self, iface): self.iface = iface
    def add_iface(self, value): self.iface.append(value)
    def insert_iface(self, index, value): self.iface[index] = value
    def get_hostname(self): return self.hostname
    def set_hostname(self, hostname): self.hostname = hostname
    def export(self, outfile, level, namespace_='', name_='network', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='network')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='network'):
        outfile.write(' hostname=%s' % (self.gds_format_string(quote_attrib(self.hostname).encode(ExternalEncoding), input_name='hostname'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='network'):
        for nameserver_ in self.nameserver:
            showIndent(outfile, level)
            outfile.write('<%snameserver>%s</%snameserver>\n' % (namespace_, self.gds_format_string(quote_xml(nameserver_).encode(ExternalEncoding), input_name='nameserver'), namespace_))
        for iface_ in self.iface:
            iface_.export(outfile, level, namespace_, name_='iface')
    def hasContent_(self):
        if (
            self.nameserver or
            self.iface
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='network'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hostname is not None and 'hostname' not in already_processed:
            already_processed.append('hostname')
            showIndent(outfile, level)
            outfile.write('hostname = "%s",\n' % (self.hostname,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('nameserver=[\n')
        level += 1
        for nameserver_ in self.nameserver:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(nameserver_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('iface=[\n')
        level += 1
        for iface_ in self.iface:
            showIndent(outfile, level)
            outfile.write('model_.iface(\n')
            iface_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('hostname')
        if value is not None and 'hostname' not in already_processed:
            already_processed.append('hostname')
            self.hostname = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'nameserver':
            nameserver_ = child_.text
            self.nameserver.append(nameserver_)
        elif nodeName_ == 'iface': 
            obj_ = iface.factory()
            obj_.build(child_)
            self.iface.append(obj_)
# end class network


class iface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, default=None, virtual=None, netmask=None, address=None, dhcp=None, gateway=None, valueOf_=None):
        self.name = _cast(None, name)
        self.default = _cast(bool, default)
        self.virtual = _cast(bool, virtual)
        self.netmask = _cast(None, netmask)
        self.address = _cast(None, address)
        self.dhcp = _cast(bool, dhcp)
        self.gateway = _cast(None, gateway)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if iface.subclass:
            return iface.subclass(*args_, **kwargs_)
        else:
            return iface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_virtual(self): return self.virtual
    def set_virtual(self, virtual): self.virtual = virtual
    def get_netmask(self): return self.netmask
    def set_netmask(self, netmask): self.netmask = netmask
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_dhcp(self): return self.dhcp
    def set_dhcp(self, dhcp): self.dhcp = dhcp
    def get_gateway(self): return self.gateway
    def set_gateway(self, gateway): self.gateway = gateway
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='iface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='iface')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='iface'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' default="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.default)), input_name='default'))
        outfile.write(' virtual="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.virtual)), input_name='virtual'))
        outfile.write(' netmask=%s' % (self.gds_format_string(quote_attrib(self.netmask).encode(ExternalEncoding), input_name='netmask'), ))
        outfile.write(' address=%s' % (self.gds_format_string(quote_attrib(self.address).encode(ExternalEncoding), input_name='address'), ))
        outfile.write(' dhcp="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.dhcp)), input_name='dhcp'))
        outfile.write(' gateway=%s' % (self.gds_format_string(quote_attrib(self.gateway).encode(ExternalEncoding), input_name='gateway'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='iface'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='iface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = %s,\n' % (self.default,))
        if self.virtual is not None and 'virtual' not in already_processed:
            already_processed.append('virtual')
            showIndent(outfile, level)
            outfile.write('virtual = %s,\n' % (self.virtual,))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.append('netmask')
            showIndent(outfile, level)
            outfile.write('netmask = "%s",\n' % (self.netmask,))
        if self.address is not None and 'address' not in already_processed:
            already_processed.append('address')
            showIndent(outfile, level)
            outfile.write('address = "%s",\n' % (self.address,))
        if self.dhcp is not None and 'dhcp' not in already_processed:
            already_processed.append('dhcp')
            showIndent(outfile, level)
            outfile.write('dhcp = %s,\n' % (self.dhcp,))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.append('gateway')
            showIndent(outfile, level)
            outfile.write('gateway = "%s",\n' % (self.gateway,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('default')
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            if value in ('true', '1'):
                self.default = True
            elif value in ('false', '0'):
                self.default = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('virtual')
        if value is not None and 'virtual' not in already_processed:
            already_processed.append('virtual')
            if value in ('true', '1'):
                self.virtual = True
            elif value in ('false', '0'):
                self.virtual = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('netmask')
        if value is not None and 'netmask' not in already_processed:
            already_processed.append('netmask')
            self.netmask = value
        value = attrs.get('address')
        if value is not None and 'address' not in already_processed:
            already_processed.append('address')
            self.address = value
        value = attrs.get('dhcp')
        if value is not None and 'dhcp' not in already_processed:
            already_processed.append('dhcp')
            if value in ('true', '1'):
                self.dhcp = True
            elif value in ('false', '0'):
                self.dhcp = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('gateway')
        if value is not None and 'gateway' not in already_processed:
            already_processed.append('gateway')
            self.gateway = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class iface


class cloud(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, topology=None, component=None):
        self.topology = topology
        if component is None:
            self.component = []
        else:
            self.component = component
    def factory(*args_, **kwargs_):
        if cloud.subclass:
            return cloud.subclass(*args_, **kwargs_)
        else:
            return cloud(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topology(self): return self.topology
    def set_topology(self, topology): self.topology = topology
    def get_component(self): return self.component
    def set_component(self, component): self.component = component
    def add_component(self, value): self.component.append(value)
    def insert_component(self, index, value): self.component[index] = value
    def export(self, outfile, level, namespace_='', name_='cloud', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='cloud')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cloud'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cloud'):
        if self.topology:
            self.topology.export(outfile, level, namespace_, name_='topology', )
        for component_ in self.component:
            component_.export(outfile, level, namespace_, name_='component')
    def hasContent_(self):
        if (
            self.topology is not None or
            self.component
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cloud'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.topology is not None:
            showIndent(outfile, level)
            outfile.write('topology=model_.topology(\n')
            self.topology.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('component=[\n')
        level += 1
        for component_ in self.component:
            showIndent(outfile, level)
            outfile.write('model_.component(\n')
            component_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'topology': 
            obj_ = topology.factory()
            obj_.build(child_)
            self.set_topology(obj_)
        elif nodeName_ == 'component': 
            obj_ = component.factory()
            obj_.build(child_)
            self.component.append(obj_)
# end class cloud


class topology(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, management=None, storage=None, service=None, valueOf_=None):
        self.management = _cast(None, management)
        self.storage = _cast(None, storage)
        self.service = _cast(None, service)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if topology.subclass:
            return topology.subclass(*args_, **kwargs_)
        else:
            return topology(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_management(self): return self.management
    def set_management(self, management): self.management = management
    def get_storage(self): return self.storage
    def set_storage(self, storage): self.storage = storage
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='topology', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='topology')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='topology'):
        outfile.write(' management=%s' % (self.gds_format_string(quote_attrib(self.management).encode(ExternalEncoding), input_name='management'), ))
        outfile.write(' storage=%s' % (self.gds_format_string(quote_attrib(self.storage).encode(ExternalEncoding), input_name='storage'), ))
        outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='topology'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='topology'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.management is not None and 'management' not in already_processed:
            already_processed.append('management')
            showIndent(outfile, level)
            outfile.write('management = "%s",\n' % (self.management,))
        if self.storage is not None and 'storage' not in already_processed:
            already_processed.append('storage')
            showIndent(outfile, level)
            outfile.write('storage = "%s",\n' % (self.storage,))
        if self.service is not None and 'service' not in already_processed:
            already_processed.append('service')
            showIndent(outfile, level)
            outfile.write('service = "%s",\n' % (self.service,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('management')
        if value is not None and 'management' not in already_processed:
            already_processed.append('management')
            self.management = value
        value = attrs.get('storage')
        if value is not None and 'storage' not in already_processed:
            already_processed.append('storage')
            self.storage = value
        value = attrs.get('service')
        if value is not None and 'service' not in already_processed:
            already_processed.append('service')
            self.service = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class topology


class component(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, service=None):
        self.name = _cast(None, name)
        if service is None:
            self.service = []
        else:
            self.service = service
    def factory(*args_, **kwargs_):
        if component.subclass:
            return component.subclass(*args_, **kwargs_)
        else:
            return component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def add_service(self, value): self.service.append(value)
    def insert_service(self, index, value): self.service[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='component', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='component')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='component'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='component'):
        for service_ in self.service:
            service_.export(outfile, level, namespace_, name_='service')
    def hasContent_(self):
        if (
            self.service
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='component'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('service=[\n')
        level += 1
        for service_ in self.service:
            showIndent(outfile, level)
            outfile.write('model_.service(\n')
            service_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'service': 
            obj_ = service.factory()
            obj_.build(child_)
            self.service.append(obj_)
# end class component


class service(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, property=None):
        self.type_ = _cast(None, type_)
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if service.subclass:
            return service.subclass(*args_, **kwargs_)
        else:
            return service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property(self, index, value): self.property[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='service', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='service')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='service'):
        outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='service'):
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property')
    def hasContent_(self):
        if (
            self.property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='service'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.property(\n')
            property_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'property': 
            obj_ = property.factory()
            obj_.build(child_)
            self.property.append(obj_)
# end class service


class property(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, valueOf_=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if property.subclass:
            return property.subclass(*args_, **kwargs_)
        else:
            return property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='property')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='property'):
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='property'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('value')
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class property


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'node'
        rootClass = node
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'node'
        rootClass = node
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="node",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'node'
        rootClass = node
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from StackOps import *\n\n')
    sys.stdout.write('import StackOps as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "cloud",
    "component",
    "cpu",
    "cpus",
    "hardware",
    "iface",
    "network",
    "nic",
    "nics",
    "node",
    "os",
    "partition",
    "partitions",
    "property",
    "service",
    "software",
    "topology"
    ]
